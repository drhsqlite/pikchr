%include {
/*
** 2020-09-01
**
** A translator for the PIC language into SVG.
**
** This code was originally written by D. Richard Hipp using documentation
** from prior PIC implementations but without reference to prior code.
** All of the code in this project is original.  The author releases all
** code into the public domain.
**
** This file implements a C-language subroutine that accepts a string
** of PIC language text and generates a second string of SVG output that
** renders the drawing defined by the input.  Space to hold the returned
** string is obtained from malloc() and should be freed by the caller.
** NULL might be returned if there is a memory allocation error.
**
** If there are error in the PIC input, the output will consist of an
** error message and the original PIC input text (inside of <pre>...</pre>).
**
** The subroutine implemented by this file is intended to be stand-alone.
** It uses no external routines other than routines commonly found in
** the standard C library.
*/
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include <math.h>
#define count(X) (sizeof(X)/sizeof(X[0]))

typedef struct Pic Pic;          /* Complete parsing context */
typedef struct PToken PToken;    /* A single token */
typedef struct PElem PElem;      /* A single element */
typedef struct PEList PEList;    /* A list of elements */
typedef struct PClass PClass;    /* Description of elements types */
typedef double PNum;             /* Numeric value */
typedef struct PPoint PPoint;    /* A position in 2-D space */
typedef struct PVar PVar;        /* script-defined variable */
typedef struct PBox PBox;        /* A bounding box */

/* Compass points */
#define CP_C      0
#define CP_N      1
#define CP_NE     2
#define CP_E      3
#define CP_SE     4
#define CP_S      5
#define CP_SW     6
#define CP_W      7
#define CP_NW     8

static const PNum pic_hdg_angle[] = {
  /* C  */    0.0,
  /* N  */    0.0,
  /* NE */   45.0,
  /* E  */   90.0,
  /* SE */  135.0,
  /* S  */  180.0,
  /* SW */  225.0,
  /* W  */  270.0,
  /* NW */  315.0,
};

/* Built-in functions */
#define FN_COS    0
#define FN_INT    1
#define FN_MAX    2
#define FN_MIN    3
#define FN_SIN    4
#define FN_SQRT   5

/* Text position flags */
#define TP_LJUST   0x01
#define TP_RJUST   0x02
#define TP_JMASK   0x03
#define TP_ABOVE   0x04
#define TP_BELOW   0x08
#define TP_VMASK   0x0c

/* An object to hold a position in 2-D space */
struct PPoint {
  PNum x, y;               /* X and Y coordinates */
};

/* A bounding box */
struct PBox {
  PPoint sw, ne;             /* Lower-left and top-right corners */
};

/* A variable created by the ID = EXPR construct of the PIC script */
struct PVar {
  const char *zName;       /* Name of the variable */
  PNum val;                /* Value of the variable */
  PVar *pNext;             /* Next variable in a list of them all */
};

/* A single token in the parser input stream
*/
struct PToken {
  const char *z;             /* Pointer to the token text */
  unsigned int n;            /* Length of the token in bytes */
  unsigned short int eType;  /* The numeric parser code */
  short int eCode;           /* Auxiliary code */
};

/* Return negative, zero, or positive if pToken is less then, equal to
** or greater than zero-terminated string z[] */
static int pic_token_eq(PToken *pToken, const char *z){
  int c = strncmp(pToken->z,z,pToken->n);
  if( c==0 && z[pToken->n]!=0 ) c = -1;
  return c;
}

/* Extra token types not generated by LEMON */
#define T_WHITESPACE 1000
#define T_ERROR      1001


/* A single element */
struct PElem {
  const PClass *type;      /* Element type */
  PEList *pSublist;        /* Substructure for [] elements */
  char *zName;             /* Name assigned to this element */
  struct PProp {
    PNum w;                /* width */
    PNum h;                /* height */
    PNum rx;               /* x-radius */
    PNum ry;               /* y-radius */
    PNum sw;               /* stroke width ("thinkness") */
    PNum dotted;           /* dotted:  <=0.0 for off */
    PNum dashed;           /* dashed:  <=0.0 for off */
    PNum chop1, chop2;     /* chop:    <=0.0 for off */
    PNum fill;             /* fill color.  Negative for off */
    PNum color;            /* Stroke color */
    char cw;               /* True for clockwise arc */
    char larrow;           /* Arrow at beginning */
    char rarrow;           /* Arrow at end */
  } prop;
  PToken aTxt[3];          /* Text with .eCode holding TP flags */
  PPoint ptAt;             /* Reference point for the object */
  int inDir, outDir;       /* Entry and exit directions */
  unsigned char nTxt;      /* Number of text values */
  int nPath;               /* Number of path points */
  PPoint *aPath;           /* Array of path points */
  PBox bbox;               /* Bounding box */
  PPoint ptEnter, ptExit;  /* Entry and exit points */
};

/* A list of elements */
struct PEList {
  int n;          /* Number of elements in the list */
  int nAlloc;     /* Allocated slots in a[] */
  PElem **a;      /* Pointers to individual elements */
};

/* Each call to the pic() subroutine uses an instance of the following
** object to pass around context to all of its subroutines.
*/
struct Pic {
  unsigned nErr;           /* Number of errors seen */
  const char *zIn;         /* Input PIC-language text.  zero-terminated */
  unsigned int nIn;        /* Number of bytes in zIn */
  char *zOut;              /* Result accumulates here */
  unsigned int nOut;       /* Bytes written to zOut[] so far */
  unsigned int nOutAlloc;  /* Space allocated to zOut[] */
  PNum wArrow;             /* Width of arrowhead at the fat end */
  PNum hArrow;             /* Height of arrowhead - dist from tip to fat end */
  int eDir;                /* Current direction */
  PElem *cur;              /* Element under construction */
  PEList *list;            /* Element list under construction */
  PPoint ptStart;          /* Starting point when list is empty */
  PVar *pVar;              /* Application-defined variables */
  PBox bbox;               /* Bounding box around all elements */
  PNum rScale;             /* Multiple to convert inches to pixels */
  char inDebug;            /* True if inside debugging print statement */
  char thenFlag;           /* True if "then" seen */
  int nRPath;              /* Number of entries on aRPath[] */
  struct {
    char isRel;               /* True for relative */
    PPoint pt;                /* Location */
  } aRPath[1000];          /* Path under construction */
};

/* Forward declarations */
static void pic_append(Pic*, const char*,int);
static void pic_append_text(Pic*,const char*,int,int);
static void pic_append_num(Pic*,PNum);
static void pic_append_x(Pic*,const char*,PNum,const char*);
static void pic_append_y(Pic*,const char*,PNum,const char*);
static void pic_append_xy(Pic*,const char*,PNum,PNum);
static void pic_append_dis(Pic*,const char*,PNum,const char*);
static void pic_append_clr(Pic*,const char*,PNum,const char*);
static void pic_append_style(Pic*,PElem*);
static void pic_append_txt(Pic*,PElem*);
static void pic_draw_arrowhead(Pic*,PPoint*pFrom,PPoint*pTo,PElem*);
static void pic_chop(Pic*,PPoint*pFrom,PPoint*pTo,PNum);
static void pic_error(Pic*,PToken*,const char*);
static void pic_elist_free(Pic*,PEList*);
static void pic_elem_free(Pic*,PElem*);
static void pic_render(Pic*,PEList*);
static PEList *pic_elist_append(Pic*,PEList*,PElem*);
static PElem *pic_elem_new(Pic*,PToken*,PToken*,PEList*);
static void pic_set_direction(Pic*,int);
static void pic_elem_setname(Pic*,PElem*,PToken*);
static void pic_set_var(Pic*,PToken*,PNum);
static PNum pic_value(Pic*,const char*,int,int*);
static PNum pic_lookup_color(Pic*,PToken*);
static PNum pic_get_var(Pic*,PToken*);
static PNum pic_color_to_num(Pic*,const char*,int);
static void pic_after_adding_attributes(Pic*,PElem*);
static void pic_elem_move(PElem*,PNum dx, PNum dy);
static void pic_elist_move(PEList*,PNum dx, PNum dy);
static void pic_set_numprop(Pic*,PToken*,PNum,PNum);
static void pic_set_dashed(Pic*,PToken*,PNum*);
static void pic_then(Pic*,PToken*,PElem*);
static void pic_add_direction(Pic*,PToken*,PNum*);
static void pic_set_from(Pic*,PElem*,PToken*,PPoint*);
static void pic_add_to(Pic*,PElem*,PToken*,PPoint*);
static void pic_set_at(Pic*,PToken*,PPoint*,PToken*);
static short int pic_nth_value(Pic*,PToken*);
static PElem *pic_find_nth(Pic*,PElem*,PToken*);
static PElem *pic_find_byname(Pic*,PElem*,PToken*);
static PPoint pic_place_of_elem(Pic*,PElem*,PToken*);
static int pic_bbox_isempty(PBox*);
static void pic_bbox_init(PBox*);
static void pic_bbox_addbox(PBox*,PBox*);
static void pic_bbox_addpt(PBox*,PPoint*);
static void pic_add_txt(Pic*,PToken*,int);
static int pic_text_position(Pic*,int,PToken*);
static PNum pic_property_of(Pic*,PElem*,PToken*);
static PNum pic_func(Pic*,PToken*,PNum,PNum);
static PPoint pic_position_between(Pic *p, PNum x, PPoint p1, PPoint p2);
static PPoint pic_position_at_angle(Pic *p, PNum dist, PNum r, PPoint pt);
static PPoint pic_position_at_hdg(Pic *p, PNum dist, PToken *pD, PPoint pt);


} // end %include

%name pic_parser
%token_prefix T_
%token_type {PToken}
%extra_context {Pic *p}

%fallback ID EDGE.

%type element_list {PEList*}
%destructor element_list {pic_elist_free(p,$$);}
%type element {PElem*}
%destructor element {pic_elem_free(p,$$);}
%type unnamed_element {PElem*}
%destructor unnamed_element {pic_elem_free(p,$$);}
%type basetype {PElem*}
%destructor basetype {pic_elem_free(p,$$);}
%type expr {PNum}
%type numproperty {PToken}
%type direction {PToken}
%type dashproperty {PToken}
%type colorproperty {PToken}
%type locproperty {PToken}
%type position {PPoint}
%type place {PPoint}
%type object {PElem*}
%type objectname {PElem*}
%type nth {PToken}
%type textposition {int}
%type rvalue {PNum}

%syntax_error {
  if( TOKEN.z && TOKEN.z[0] ){
    pic_error(p, &TOKEN, "syntax error");
  }else{
    pic_error(p, 0, "syntax error");
  }
}

document ::= element_list(X).  {pic_render(p,X);}


element_list(A) ::= element(X).   { A = pic_elist_append(p,0,X); }
element_list(A) ::= element_list(B) EOL element(X).
                      { A = pic_elist_append(p,B,X); }


element(A) ::= .   { A = 0; }
element(A) ::= direction(D).  { pic_set_direction(p,D.eType);  A=0; }
element(A) ::= ID(N) ASSIGN rvalue(X). {pic_set_var(p,&N,X); A = 0;}
element(A) ::= FILL(N) ASSIGN rvalue(X). {pic_set_var(p,&N,X); A = 0;}
element(A) ::= COLOR(N) ASSIGN rvalue(X). {pic_set_var(p,&N,X); A = 0;}
element(A) ::= PLACENAME(N) COLON unnamed_element(X).
               { A = X;  pic_elem_setname(p,X,&N); }
element(A) ::= unnamed_element(X).  {A = X;}
element(A) ::= print prlist.  {pic_append(p," -->\n",5); A=0; p->inDebug=0;}

// PLACENAME might actually be a color name (ex: DarkBlue).  But we
// cannot make it part of expr due to parsing ambiguities.  The
// rvalue non-terminal means "general expression or a colorname"
rvalue(A) ::= expr(A).
rvalue(A) ::= PLACENAME(C).  {A = pic_lookup_color(p,&C);}

print ::= PRINT.  {pic_append(p,"<!-- ",5); p->inDebug = 1;}
prlist ::= pritem.
prlist ::= prlist prsep pritem.
pritem ::= rvalue(X). {pic_append_num(p,X);}
pritem ::= STRING(S). {pic_append_text(p,S.z+1,S.n-2,0);}
prsep  ::= COMMA. {pic_append(p, " ", 1);}

unnamed_element(A) ::= basetype(X) attribute_list.  
                          {A = X; pic_after_adding_attributes(p,A);}

basetype(A) ::= ID(N).                   {A = pic_elem_new(p,&N,0,0); }
basetype(A) ::= STRING(N) textposition(P).
                            {N.eCode = P; A = pic_elem_new(p,0,&N,0); }
basetype(A) ::= LB savelist(L) element_list(X) RB.
      { A = pic_elem_new(p,0,0,X); p->list = L; }

%type savelist {PEList*}
%destructor savelist {pic_elist_free(p,$$);}
savelist(A) ::= .   {A = p->list; p->list = 0;}

direction(A) ::= UP(A).
direction(A) ::= DOWN(A).
direction(A) ::= LEFT(A).
direction(A) ::= RIGHT(A).

attribute_list ::=.
attribute_list ::= attribute_list attribute.
attribute ::= numproperty(P) expr(X) PERCENT.
                                      { pic_set_numprop(p,&P,0.0,X/100.0); }
attribute ::= numproperty(P) expr(X). { pic_set_numprop(p,&P,X,0.0); }
attribute ::= dashproperty(P) expr(X).  { pic_set_dashed(p,&P,&X); }
attribute ::= dashproperty(P).          { pic_set_dashed(p,&P,0);  }
attribute ::= colorproperty(P) rvalue(X). { pic_set_numprop(p,&P,X,0.0); }
attribute ::= direction(D) expr(X). { pic_add_direction(p,&D,&X);}
attribute ::= direction(D).         { pic_add_direction(p,&D,0); }
attribute ::= FROM(T) position(X).  { pic_set_from(p,p->cur,&T,&X); }
attribute ::= TO(T) position(X).    { pic_add_to(p,p->cur,&T,&X); }
attribute ::= THEN(T).              { pic_then(p, &T, p->cur); }
attribute ::= boolproperty.
attribute ::= AT(A) position(P).                    { pic_set_at(p,0,&P,&A); }
attribute ::= WITH DOT_E EDGE(E) AT(A) position(P). { pic_set_at(p,&E,&P,&A); }
attribute ::= WITH EDGE(E) AT(A) position(P).       { pic_set_at(p,&E,&P,&A); }
attribute ::= SAME.
attribute ::= SAME AS object.
attribute ::= BEHIND object.
attribute ::= STRING(T) textposition(P).        {pic_add_txt(p,&T,P);}

// Properties that require an argument
numproperty(A) ::= HEIGHT|WIDTH|RADIUS|RX|RY|DIAMETER|THICKNESS(P).  {A = P;}

// Properties with optional arguments
dashproperty(A) ::= DOTTED(A).
dashproperty(A) ::= DASHED(A).
dashproperty(A) ::= CHOP(A).

// Color properties
colorproperty(A) ::= FILL(A).
colorproperty(A) ::= COLOR(A).

// Properties with no argument
boolproperty ::= CW.          {p->cur->prop.cw = 1;}
boolproperty ::= CCW.         {p->cur->prop.cw = 0;}
boolproperty ::= LARROW.      {p->cur->prop.larrow=1; p->cur->prop.rarrow=0; }
boolproperty ::= RARROW.      {p->cur->prop.larrow=0; p->cur->prop.rarrow=1; }
boolproperty ::= LRARROW.     {p->cur->prop.larrow=1; p->cur->prop.rarrow=1; }
boolproperty ::= INVIS.       {p->cur->prop.sw = 0.0;}

textposition(A) ::= .   {A = 0;}
textposition(A) ::= textposition(B) CENTER|LJUST|RJUST|ABOVE|BELOW(F).
                        {A = pic_text_position(p,B,&F);}


position(A) ::= expr(X) COMMA expr(Y).                {A.x=X; A.y=Y;}
position(A) ::= place(A).
position(A) ::= place(B) PLUS expr(X) COMMA expr(Y).  {A.x=B.x+X; A.y=B.y+Y;}
position(A) ::= place(B) MINUS expr(X) COMMA expr(Y). {A.x=B.x+X; A.y=B.y+Y;}
position(A) ::= place(B) PLUS LP expr(X) COMMA expr(Y) RP.
                                                      {A.x=B.x+X; A.y=B.y+Y;}
position(A) ::= place(B) MINUS LP expr(X) COMMA expr(Y) RP.
                                                      {A.x=B.x+X; A.y=B.y+Y;}
position(A) ::= LP position(X) COMMA position(Y) RP.  {A.x=X.x; A.y=Y.y;}
position(A) ::= LP position(X) RP.                    {A=X;}
position(A) ::= expr(X) OF THE WAY BETWEEN position(P1) AND position(P2).
                         {A = pic_position_between(p,X,P1,P2);}
position(A) ::= expr(X) BETWEEN position(P1) AND position(P2).
                         {A = pic_position_between(p,X,P1,P2);}
position(A) ::= expr(X) ABOVE position(B).    {A=B; A.y += X;}
position(A) ::= expr(X) BELOW position(B).    {A=B; A.y -= X;}
position(A) ::= expr(X) LEFT OF position(B).  {A=B; A.x -= X;}
position(A) ::= expr(X) RIGHT OF position(B). {A=B; A.x += X;}
position(A) ::= expr(D) EDGE(E) OF position(P).
                                        {A = pic_position_at_hdg(p,D,&E,P);}
position(A) ::= expr(D) ANGLE expr(G) FROM position(P).
                                        {A = pic_position_at_angle(p,D,G,P);}

place(A) ::= object(O).                 {A = pic_place_of_elem(p,O,0);}
place(A) ::= object(O) DOT_E EDGE(X).   {A = pic_place_of_elem(p,O,&X);}
place(A) ::= object(O) DOT_L START(X).  {A = pic_place_of_elem(p,O,&X);}
place(A) ::= object(O) DOT_L END(X).    {A = pic_place_of_elem(p,O,&X);}
place(A) ::= START(X) OF object(O).     {A = pic_place_of_elem(p,O,&X);}
place(A) ::= END(X) OF object(O).       {A = pic_place_of_elem(p,O,&X);}
place(A) ::= EDGE(X) OF object(O).      {A = pic_place_of_elem(p,O,&X);}

object(A) ::= objectname(A).
object(A) ::= nth(N).                     {A = pic_find_nth(p,0,&N);}
object(A) ::= nth(N) OF|IN object(B).     {A = pic_find_nth(p,B,&N);}

objectname(A) ::= PLACENAME(N).           {A = pic_find_byname(p,0,&N);}
objectname(A) ::= objectname(B) DOT_U PLACENAME(N).
                                          {A = pic_find_byname(p,B,&N);}

nth(A) ::= NTH(N) ID(ID).            {A=ID; A.eCode = pic_nth_value(p,&N); }
nth(A) ::= NTH(N) LAST ID(ID).       {A=ID; A.eCode = -pic_nth_value(p,&N); }
nth(A) ::= LAST ID(ID).              {A=ID; A.eCode = -1;}
nth(A) ::= LAST(ID).                 {A=ID; A.eCode = -1;}
nth(A) ::= NTH(N) LB(ID) RB.         {A=ID; A.eCode = pic_nth_value(p,&N);}
nth(A) ::= NTH(N) LAST LB(ID) RB.    {A=ID; A.eCode = -pic_nth_value(p,&N);}
nth(A) ::= LAST LB(ID) RB.           {A=ID; A.eCode = -1; }

%left OF.
%left PLUS MINUS.
%left STAR SLASH PERCENT.
%right UMINUS.

expr(A) ::= expr(X) PLUS expr(Y).     {A=X+Y;}
expr(A) ::= expr(X) MINUS expr(Y).    {A=X-Y;}
expr(A) ::= expr(X) STAR expr(Y).     {A=X*Y;}
expr(A) ::= expr(X) SLASH(E) expr(Y).    {
  if( Y==0.0 ){ pic_error(p, &E, "division by zero"); A = 0.0; }
  else{ A = X/Y; }
}
expr(A) ::= MINUS expr(X). [UMINUS]  {A=-X;}
expr(A) ::= PLUS expr(X). [UMINUS]   {A=X;}
expr(A) ::= LP expr(X) RP.           {A=X;}
expr(A) ::= NUMBER(N).               {A=atof(N.z);}
expr(A) ::= ID(N).                   {A=pic_get_var(p,&N);}
expr(A) ::= HEXRGB(X).               {A=pic_color_to_num(p,X.z,X.n);}
expr(A) ::= FUNC1(F) LP expr(X) RP.               {A = pic_func(p,&F,X,0.0);}
expr(A) ::= FUNC2(F) LP expr(X) COMMA expr(Y) RP. {A = pic_func(p,&F,X,Y);}

expr(A) ::= object(O) DOT_L locproperty(P).    {A=pic_property_of(p,O,&P);}
expr(A) ::= object(O) DOT_L numproperty(P).    {A=pic_property_of(p,O,&P);}
expr(A) ::= object(O) DOT_L dashproperty(P).   {A=pic_property_of(p,O,&P);}
expr(A) ::= object(O) DOT_L colorproperty(P).  {A=pic_property_of(p,O,&P);}
expr(A) ::= object(O) DOT_E EDGE(E) DOT_L X.   {A=pic_place_of_elem(p,O,&E).x;}
expr(A) ::= object(O) DOT_E EDGE(E) DOT_L Y.   {A=pic_place_of_elem(p,O,&E).y;}
expr(A) ::= LP locproperty(P) OF object(O) RP.   {A=pic_property_of(p,O,&P);}
expr(A) ::= LP dashproperty(P) OF object(O) RP.  {A=pic_property_of(p,O,&P);}
expr(A) ::= LP numproperty(P) OF object(O) RP.   {A=pic_property_of(p,O,&P);}
expr(A) ::= LP colorproperty(P) OF object(O) RP. {A=pic_property_of(p,O,&P);}

locproperty(A) ::= X|Y|TOP|BOTTOM|LEFT|RIGHT(A).

%code {


/* Chart of the 140 official HTML color names */
static const struct {
  const char *zName;  /* Name of the color */
  unsigned int val;   /* RGB value */
} aColor[] = {
  { "AliceBlue",                   0xf0f8ff },
  { "AntiqueWhite",                0xfaebd7 },
  { "Aqua",                        0x00ffff },
  { "AquaMarine",                  0x7fffd4 },
  { "Azure",                       0xf0ffff },
  { "Beige",                       0xf5f5dc },
  { "Bisque",                      0xffe4c4 },
  { "Black",                       0x000000 },
  { "BlanchedAlmond",              0xffebcd },
  { "Blue",                        0x0000ff },
  { "BlueViolet",                  0x8a2be2 },
  { "Brown",                       0xa52a2a },
  { "BurlyWood",                   0xdeb887 },
  { "CadetBlue",                   0x5f9ea0 },
  { "Chartreuse",                  0x7fff00 },
  { "Chocolate",                   0xd2691e },
  { "Coral",                       0xff7f50 },
  { "CornFlowerBlue",              0x6495ed },
  { "Cornsilk",                    0xfff8dc },
  { "Crimson",                     0xdc143c },
  { "Cyan",                        0x00ffff },
  { "DarkBlue",                    0x00008b },
  { "DarkCyan",                    0x008b8b },
  { "DarkGoldenRod",               0xb8860b },
  { "DarkGray",                    0xa9a9a9 },
  { "DarkGreen",                   0x006400 },
  { "DarkKhaki",                   0xbdb76b },
  { "DarkMagenta",                 0x8b008b },
  { "DarkOliveGreen",              0x556b2f },
  { "DarkOrange",                  0xff8c00 },
  { "DarkOrchid",                  0x9932cc },
  { "DarkRed",                     0x8b0000 },
  { "DarkSalmon",                  0xe9967a },
  { "DarkSeaGreen",                0x8fbc8f },
  { "DarkSlateBlue",               0x483d8b },
  { "DarkSlateGray",               0x2f4f4f },
  { "DarkTurquoise",               0x00ced1 },
  { "DarkViolet",                  0x9400d3 },
  { "DeepPink",                    0xff1493 },
  { "DeepSkyBlue",                 0x00bfff },
  { "DimGray",                     0x696969 },
  { "DodgerBlue",                  0x1e90ff },
  { "FireBrick",                   0xb22222 },
  { "FloralWhite",                 0xfffaf0 },
  { "ForestGreen",                 0x228b22 },
  { "Fuchsia",                     0xff00ff },
  { "Gainsboro",                   0xdcdcdc },
  { "GhostWhite",                  0xf8f8ff },
  { "Gold",                        0xffd700 },
  { "GoldenRod",                   0xdaa520 },
  { "Gray",                        0x808080 },
  { "Green",                       0x008000 },
  { "GreenYellow",                 0xadff2f },
  { "HoneyDew",                    0xf0fff0 },
  { "HotPink",                     0xff69b4 },
  { "IndianRed",                   0xcd5c5c },
  { "Indigo",                      0x4b0082 },
  { "Ivory",                       0xfffff0 },
  { "Khaki",                       0xf0e68c },
  { "Lavender",                    0xe6e6fa },
  { "LavenderBlush",               0xfff0f5 },
  { "LawnGreen",                   0x7cfc00 },
  { "LemonChiffon",                0xfffacd },
  { "LightBlue",                   0xadd8e6 },
  { "LightCoral",                  0xf08080 },
  { "LightCyan",                   0xe0ffff },
  { "LightGoldenrodYellow",        0xfafad2 },
  { "LightGray",                   0xd3d3d3 },
  { "LightGreen",                  0x90ee90 },
  { "LightPink",                   0xffb6c1 },
  { "LightSalmon",                 0xffa07a },
  { "LightSeaGreen",               0x20b2aa },
  { "LightSkyBlue",                0x87cefa },
  { "LightSlateGray",              0x778899 },
  { "LightSteelBlue",              0xb0c4de },
  { "LightYellow",                 0xffffe0 },
  { "Lime",                        0x00ff00 },
  { "LimeGreen",                   0x32cd32 },
  { "Linen",                       0xfaf0e6 },
  { "Magenta",                     0xff00ff },
  { "Maroon",                      0x800000 },
  { "MediumAquaMarine",            0x66cdaa },
  { "MediumBlue",                  0x0000cd },
  { "MediumOrchid",                0xba55d3 },
  { "MediumPurple",                0x9370d8 },
  { "MediumSeaGreen",              0x3cb371 },
  { "MediumSlateBlue",             0x7b68ee },
  { "MediumSpringGreen",           0x00fa9a },
  { "MediumTurquoise",             0x48d1cc },
  { "MediumVioletRed",             0xc71585 },
  { "MidnightBlue",                0x191970 },
  { "MintCream",                   0xf5fffa },
  { "MistyRose",                   0xffe4e1 },
  { "Moccasin",                    0xffe4b5 },
  { "NavajoWhite",                 0xffdead },
  { "Navy",                        0x000080 },
  { "OldLace",                     0xfdf5e6 },
  { "Olive",                       0x808000 },
  { "OliveDrab",                   0x6b8e23 },
  { "Orange",                      0xffa500 },
  { "OrangeRed",                   0xff4500 },
  { "Orchid",                      0xda70d6 },
  { "PaleGoldenRod",               0xeee8aa },
  { "PaleGreen",                   0x98fb98 },
  { "PaleTurquoise",               0xafeeee },
  { "PaleVioletRed",               0xdb7093 },
  { "PapayaWhip",                  0xffefd5 },
  { "PeachPuff",                   0xffdab9 },
  { "Peru",                        0xcd853f },
  { "Pink",                        0xffc0cb },
  { "Plum",                        0xdda0dd },
  { "PowderBlue",                  0xb0e0e6 },
  { "Purple",                      0x800080 },
  { "Red",                         0xff0000 },
  { "RosyBrown",                   0xbc8f8f },
  { "RoyalBlue",                   0x4169e1 },
  { "SaddleBrown",                 0x8b4513 },
  { "Salmon",                      0xfa8072 },
  { "SandyBrown",                  0xf4a460 },
  { "SeaGreen",                    0x2e8b57 },
  { "SeaShell",                    0xfff5ee },
  { "Sienna",                      0xa0522d },
  { "Silver",                      0xc0c0c0 },
  { "SkyBlue",                     0x87ceeb },
  { "SlateBlue",                   0x6a5acd },
  { "SlateGray",                   0x708090 },
  { "Snow",                        0xfffafa },
  { "SpringGreen",                 0x00ff7f },
  { "SteelBlue",                   0x4682b4 },
  { "Tan",                         0xd2b48c },
  { "Teal",                        0x008080 },
  { "Thistle",                     0xd8bfd8 },
  { "Tomato",                      0xff6347 },
  { "Turquoise",                   0x40e0d0 },
  { "Violet",                      0xee82ee },
  { "Wheat",                       0xf5deb3 },
  { "White",                       0xffffff },
  { "WhiteSmoke",                  0xf5f5f5 },
  { "Yellow",                      0xffff00 },
  { "YellowGreen",                 0x9acd32 },
};

/* Built-in variable names */
static const struct { const char *zName; PNum val; } aBuiltin[] = {
  { "arcrad",      0.25 },
  { "arrowhead",   2.0  },
  { "arrowht",     0.1  },
  { "arrowwid",    0.05 },
  { "boxht",       0.5  },
  { "boxwid",      0.75 },
  { "circlerad",   0.25 },
  { "color",       0.0  },
  { "dashwid",     0.05 },
  { "ellipseht",   0.5  },
  { "ellipsewid",  0.75 },
  { "fill",        -1.0 },
  { "lineht",      0.5  },
  { "linewid",     0.5  },
  { "movewid",     0.5  },
  { "scale",       1.0  },
  { "textht",      0.5  },
  { "textwid",     0.75 },
  { "thickness",   0.01 },
};


/* Methods for the "arc" class */
static void arcInit(Pic *p, PElem *pElem){
  pElem->prop.w = pic_value(p, "arcrad",6,0);
  pElem->prop.h = pElem->prop.w;
}

/* Methods for the "arrow" class */
static void arrowInit(Pic *p, PElem *pElem){
  pElem->prop.w = pic_value(p, "linewid",7,0);
  pElem->prop.h = pic_value(p, "lineht",6,0);
  pElem->prop.rarrow = 1;
}

/* Methods for the "box" class */
static void boxInit(Pic *p, PElem *pElem){
  pElem->prop.w = pic_value(p, "boxwid",6,0);
  pElem->prop.h = pic_value(p, "boxht",5,0);
}
static PPoint boxOffset(Pic *p, PElem *pElem, int cp){
  PPoint pt;
  pt.x = pElem->prop.w*0.5;
  pt.y = pElem->prop.h*0.5;
  switch( cp ){
    case CP_C:   pt.x = 0.0;   pt.y = 0.0;    break;
    case CP_N:   pt.x = 0.0;                  break;
    case CP_NE:                               break;
    case CP_E:                 pt.y = 0.0;    break;
    case CP_SE:                pt.y = -pt.y;  break;
    case CP_S:   pt.x = 0.0;   pt.y = -pt.y;  break;
    case CP_SW:  pt.x = -pt.x; pt.y = -pt.y;  break;
    case CP_W:   pt.x = -pt.x; pt.y = 0.0;    break;
    case CP_NW:  pt.x = -pt.x;                break;
  }
  return pt;
}
static void boxRender(Pic *p, PElem *pElem){
  PNum w2 = 0.5*pElem->prop.w;
  PNum h2 = 0.5*pElem->prop.h;
  PPoint pt = pElem->ptAt;
  if( pElem->prop.sw>0.0 ){
    pic_append_xy(p,"<path d=\"M", pt.x-w2,pt.y-h2);
    pic_append_xy(p,"L", pt.x+w2,pt.y-h2);
    pic_append_xy(p,"L", pt.x+w2,pt.y+h2);
    pic_append_xy(p,"L", pt.x-w2,pt.y+h2);
    pic_append(p,"Z\" ",-1);
    pic_append_style(p,pElem);
    pic_append(p,"\" />\n", -1);
  }
  pic_append_txt(p, pElem);
}

/* Methods for the "circle" class */
static void circleInit(Pic *p, PElem *pElem){
  pElem->prop.w = pic_value(p, "circlerad",9,0)*2;
  pElem->prop.h = pElem->prop.w;
}

static void circleRender(Pic *p, PElem *pElem){
  PNum w = pElem->prop.w;
  PPoint pt = pElem->ptAt;
  if( pElem->prop.sw>0.0 ){
    pic_append_x(p,"<circle cx=\"", pt.x, "\"");
    pic_append_y(p," cy=\"", pt.y, "\"");
    pic_append_dis(p," r=\"", w/2.0, "\"");
    pic_append_style(p,pElem);
    pic_append(p,"\" />\n", -1);
  }
  pic_append_txt(p, pElem);
}

/* Methods for the "cylinder" class */
static void cylinderInit(Pic *p, PElem *pElem){
  pElem->prop.w = pic_value(p, "boxwid",6,0);
  pElem->prop.h = pic_value(p, "boxht",5,0)*2;
}

/* Methods for the "document" class */
static void documentInit(Pic *p, PElem *pElem){
  pElem->prop.w = pic_value(p, "boxwid",6,0);
  pElem->prop.h = pic_value(p, "boxht",5,0)*2;
}

/* Methods for the "ellipse" class */
static void ellipseInit(Pic *p, PElem *pElem){
  pElem->prop.w = pic_value(p, "ellipsewid",10,0);
  pElem->prop.h = pic_value(p, "ellipseht",9,0);
}
static PPoint ellipseOffset(Pic *p, PElem *pElem, int cp){
  PPoint pt;
  PNum w = pElem->prop.w*0.5;
  PNum w2 = w*0.70710678118654747608;
  PNum h = pElem->prop.h*0.5;
  PNum h2 = w*0.70710678118654747608;
  switch( cp ){
    case CP_C:   pt.x = 0.0;   pt.y = 0.0;    break;
    case CP_N:   pt.x = 0.0;   pt.y = h;      break;
    case CP_NE:  pt.x = w2;    pt.y = h2;     break;
    case CP_E:   pt.x = w;     pt.y = 0.0;    break;
    case CP_SE:  pt.x = w2;    pt.y = -h2;    break;
    case CP_S:   pt.x = 0.0;   pt.y = -h;     break;
    case CP_SW:  pt.x = -w2;   pt.y = -h2;    break;
    case CP_W:   pt.x = -w;    pt.y = 0.0;    break;
    case CP_NW:  pt.x = -w2;   pt.y = h2;     break;
  }
  return pt;
}
static void ellipseRender(Pic *p, PElem *pElem){
  PNum w = pElem->prop.w;
  PNum h = pElem->prop.h;
  PPoint pt = pElem->ptAt;
  if( pElem->prop.sw>0.0 ){
    pic_append_x(p,"<ellipse cx=\"", pt.x, "\"");
    pic_append_y(p," cy=\"", pt.y, "\"");
    pic_append_dis(p," rx=\"", w/2.0, "\"");
    pic_append_dis(p," ry=\"", h/2.0, "\"");
    pic_append_style(p,pElem);
    pic_append(p,"\" />\n", -1);
  }
  pic_append_txt(p, pElem);
}


/* Methods for the "folder" class */
static void folderInit(Pic *p, PElem *pElem){
  pElem->prop.w = pic_value(p, "boxwid",6,0);
  pElem->prop.h = pic_value(p, "boxht",5,0)*1.5;
}

/* Methods for the "line" class */
static void lineInit(Pic *p, PElem *pElem){
  pElem->prop.w = pic_value(p, "linewid",7,0);
  pElem->prop.h = pic_value(p, "lineht",6,0);
}
static void lineRender(Pic *p, PElem *pElem){
  int i;
  if( pElem->prop.sw>0.0 ){
    const char *z = "<path d=\"M";
    int n = pElem->nPath;
    if( pElem->prop.chop1>0.0 ){
      pic_chop(p,&pElem->aPath[1],&pElem->aPath[0],pElem->prop.chop1);
    }
    if( pElem->prop.chop2>0.0 ){
      pic_chop(p,&pElem->aPath[n-2],&pElem->aPath[n-1],pElem->prop.chop2);
    }
    if( pElem->prop.larrow ){
      pic_draw_arrowhead(p,&pElem->aPath[1],&pElem->aPath[0],pElem);
    }
    if( pElem->prop.rarrow ){
      pic_draw_arrowhead(p,&pElem->aPath[n-2],&pElem->aPath[n-1],pElem);
    }
    for(i=0; i<pElem->nPath; i++){
      pic_append_xy(p,z,pElem->aPath[i].x,pElem->aPath[i].y);
      z = "L";
    }
    pic_append(p,"\" ",-1);
    pic_append_style(p,pElem);
    pic_append(p,"\" />\n", -1);
  }
  pic_append_txt(p, pElem);

}

/* Methods for the "move" class */
static void moveInit(Pic *p, PElem *pElem){
  pElem->prop.w = pic_value(p, "movewid",7,0);
  pElem->prop.h = pic_value(p, "moveht",6,0);
}

/* Methods for the "spline" class */
static void splineInit(Pic *p, PElem *pElem){
  pElem->prop.w = pic_value(p, "linewid",7,0);
  pElem->prop.h = pic_value(p, "lineht",6,0);
}

/* Methods for the "text" class */
static void textInit(Pic *p, PElem *pElem){
  pElem->prop.w = pic_value(p, "textwid",7,0);
  pElem->prop.h = pic_value(p, "textht",6,0);
  pElem->prop.sw = 0.0;
}

/* Methods for the "sublist" class */
static void sublistInit(Pic *p, PElem *pElem){
  PEList *pList = pElem->pSublist;
  int i;
  pic_bbox_init(&pElem->bbox);
  for(i=0; i<pList->n; i++){
    pic_bbox_addbox(&pElem->bbox, &pList->a[i]->bbox);
  }
  pElem->prop.w = pElem->bbox.ne.x - pElem->bbox.sw.x;
  pElem->prop.h = pElem->bbox.ne.y - pElem->bbox.sw.y;
}

/*
** The following array holds all the different kinds of named
** elements.  The special STRING and [] elements are separate.
*/
struct PClass {
  const char *zName;                 /* Name of class */
  char isLine;                       /* True if a line class */
  void (*xInit)(Pic*,PElem*);        /* Initializer */
  void (*xAfter)(Pic*,PElem*);       /* Processing after attributes rcvd */
  PPoint (*xOffset)(Pic*,PElem*,int); /* Compute rel offset to compass pt */
  void (*xRender)(Pic*,PElem*);      /* Render */
};
static const PClass aClass[] = {
   {  /* name */          "arc",
      /* isline */        1,
      /* xInit */         arcInit,
      /* xAfter */        0,
      /* xOffset */       0,
      /* xRender */       0 
   },
   {  /* name */          "arrow",
      /* isline */        1,
      /* xInit */         arrowInit,
      /* xAfter */        0,
      /* xOffset */       0,
      /* xRender */       lineRender 
   },
   {  /* name */          "box",
      /* isline */        0,
      /* xInit */         boxInit,
      /* xAfter */        0,
      /* xOffset */       0,
      /* xRender */       boxRender 
   },
   {  /* name */          "circle",
      /* isline */        0,
      /* xInit */         circleInit,
      /* xAfter */        0,
      /* xOffset */       ellipseOffset,
      /* xRender */       circleRender 
   },
   {  /* name */          "cylinder",
      /* isline */        0,
      /* xInit */         cylinderInit,
      /* xAfter */        0,
      /* xOffset */       0,
      /* xRender */       0 
   },
   {  /* name */          "document",
      /* isline */        0,
      /* xInit */         documentInit,
      /* xAfter */        0,
      /* xOffset */       0,
      /* xRender */       0 
   },
   {  /* name */          "ellipse",
      /* isline */        0,
      /* xInit */         ellipseInit,
      /* xAfter */        0,
      /* xOffset */       ellipseOffset,
      /* xRender */       ellipseRender
   },
   {  /* name */          "folder",
      /* isline */        0,
      /* xInit */         folderInit,
      /* xAfter */        0,
      /* xOffset */       0,
      /* xRender */       0 
   },
   {  /* name */          "line",
      /* isline */        1,
      /* xInit */         lineInit,
      /* xAfter */        0,
      /* xOffset */       0,
      /* xRender */       lineRender
   },
   {  /* name */          "move",
      /* isline */        1,
      /* xInit */         moveInit,
      /* xAfter */        0,
      /* xOffset */       0,
      /* xRender */       0
   },
   {  /* name */          "spline",
      /* isline */        1,
      /* xInit */         splineInit,
      /* xAfter */        0,
      /* xOffset */       0,
      /* xRender */       lineRender
   },
};
static const PClass sublistClass = 
   {  /* name */          "[]",
      /* isline */        0,
      /* xInit */         sublistInit,
      /* xAfter */        0,
      /* xOffset */       0,
      /* xRender */       0 
   };
static const PClass textClass = 
   {  /* name */          "text",
      /* isline */        0,
      /* xInit */         textInit,
      /* xAfter */        0,
      /* xOffset */       0,
      /* xRender */       boxRender 
   };


/*
** Reduce the length of the line segment by amt (if possible) by
** modifying t.
*/
static void pic_chop(Pic *p, PPoint *f, PPoint *t, PNum amt){
  PNum dx = t->x - f->x;
  PNum dy = t->y - f->y;
  PNum dist = sqrt(dx*dx + dy+dy);
  PNum r;
  if( dist<=amt ){
    *t = *f;
    return;
  }
  r = 1.0 - amt/dist;
  t->x = f->x + r*dx;
  t->y = f->y + r*dy;
}

/*
** Draw an error head on the end of the line segment from pFrom to pTo.
** Also, shorten the line segment (by changing the value of pTo) so that
** the arrow ends in a point.
*/
static void pic_draw_arrowhead(Pic *p, PPoint *f, PPoint *t, PElem *pElem){
  PNum dx = t->x - f->x;
  PNum dy = t->y - f->y;
  PNum dist = sqrt(dx*dx + dy+dy);
  PNum h = p->hArrow * pElem->prop.sw;
  PNum w = p->wArrow * pElem->prop.sw;
  PNum e1, ddx, ddy;
  PNum bx, by;
  if( dist<=0.0 ) return;  /* Unable */
  dx /= dist;
  dy /= dist;
  e1 = dist - h;
  if( e1<0.0 ){
    e1 = 0.0;
    h = dist;
  }
  ddx = -w*dy;
  ddy = w*dx;
  bx = f->x + e1*dx;
  by = f->y + e1*dy;
  pic_append_xy(p,"<polygon points=\"", t->x, t->y);
  pic_append_xy(p," ",bx-ddx, by-ddy);
  pic_append_xy(p," ",bx+ddx, by+ddy);
  pic_append_clr(p,"\" style=\"fill:",pElem->prop.color,"\"/>\n");
  pic_chop(p,f,t,h/2);
}

/*
** Compute the relative office of a edge from the reference for a
** an element.
*/
static PPoint pic_elem_offset(Pic *p, PElem *pElem, int cp){
  if( pElem->type->xOffset==0 ){
    return boxOffset(p, pElem, cp);
  }else{
    return pElem->type->xOffset(p, pElem, cp);
  }
}


/*
** Append raw text to zOut
*/
static void pic_append(Pic *p, const char *zText, int n){
  if( n<0 ) n = (int)strlen(zText);
  if( p->nOut+n>=p->nOutAlloc ){
    int nNew = (p->nOut+n)*2 + 1;
    char *z = realloc(p->zOut, nNew);
    if( z==0 ){
      pic_error(p, 0, 0);
      return;
    }
    p->zOut = z;
    p->nOutAlloc = n;
  }
  memcpy(p->zOut+p->nOut, zText, n);
  p->nOut += n;
  p->zOut[p->nOut] = 0;
}

/*
** Append text to zOut with HTML characters escaped.
*/
static void pic_append_text(Pic *p, const char *zText, int n, int bStrict){
  int i;
  char c;
  if( bStrict ) bStrict = '"';
  if( n<0 ) n = (int)strlen(zText);
  while( n>0 ){
    for(i=0; i<n && (c=zText[i])!='<' && c!='>' && c!='&' && c!=bStrict; i++){}
    if( i ) pic_append(p, zText, i);
    if( i==n ) break;
    switch( c ){
      case '<': {  pic_append(p, "&lt;", 4);  break;  }
      case '>': {  pic_append(p, "&gt;", 4);  break;  }
      case '&': {  pic_append(p, "&amp;", 5);  break;  }
      case '"': {  pic_append(p, "&quot;", 6);  break;  }
    }
    i++;
    n -= i;
    zText += i;
    i = 0;
  }
}

/* Append a PNum value
*/
static void pic_append_num(Pic *p, PNum v){
  char buf[100];
  snprintf(buf, sizeof(buf)-1, "%.10g", (double)v);
  buf[sizeof(buf)-1] = 0;
  pic_append(p, buf, -1);
}

/* Append a PNum value surrounded by text.  Do coordinate transformations
** on the value.
*/
static void pic_append_x(Pic *p, const char *z1, PNum v, const char *z2){
  char buf[200];
  v -= p->bbox.sw.x;
  snprintf(buf, sizeof(buf)-1, "%s%d%s", z1, (int)(p->rScale*v), z2);
  buf[sizeof(buf)-1] = 0;
  pic_append(p, buf, -1);
}
static void pic_append_y(Pic *p, const char *z1, PNum v, const char *z2){
  char buf[200];
  v = p->bbox.ne.y - v;
  snprintf(buf, sizeof(buf)-1, "%s%d%s", z1, (int)(p->rScale*v), z2);
  buf[sizeof(buf)-1] = 0;
  pic_append(p, buf, -1);
}
static void pic_append_xy(Pic *p, const char *z1, PNum x, PNum y){
  char buf[200];
  x = x - p->bbox.sw.x;
  y = p->bbox.ne.y - y;
  snprintf(buf, sizeof(buf)-1, "%s%d,%d", z1,
       (int)(p->rScale*x), (int)(p->rScale*y));
  buf[sizeof(buf)-1] = 0;
  pic_append(p, buf, -1);
}
static void pic_append_dis(Pic *p, const char *z1, PNum v, const char *z2){
  char buf[200];
  snprintf(buf, sizeof(buf)-1, "%s%d%s", z1, (int)(p->rScale*v), z2);
  buf[sizeof(buf)-1] = 0;
  pic_append(p, buf, -1);
}
static void pic_append_clr(Pic *p, const char *z1, PNum v, const char *z2){
  char buf[200];
  int x = (int)v;
  int r = (x>>16) & 0xff;
  int g = (x>>8) & 0xff;
  int b = x & 0xff;
  snprintf(buf, sizeof(buf)-1, "%srgb(%d,%d,%d)%s", z1, r, g, b, z2);
  buf[sizeof(buf)-1] = 0;
  pic_append(p, buf, -1);
}

/* Append a style="..." text.  But, leave the quote unterminated, in case
** the caller wants to add some more.
*/
static void pic_append_style(Pic *p, PElem *pElem){
  pic_append(p, "style=\"", -1);
  if( pElem->prop.fill>=0 ){
    pic_append_clr(p, "fill:", pElem->prop.fill, ";");
  }else{
    pic_append(p,"fill:none;",-1);
  }
  if( pElem->prop.sw>0.0 ){
    PNum sw = pElem->prop.sw;
    if( sw*p->rScale<1.0 ) sw = 1.1/p->rScale;
    pic_append_dis(p, "stroke-width:", sw, ";");
    pic_append_clr(p, "stroke:",pElem->prop.color,";");
    if( pElem->prop.dotted>0.0 ){
      PNum v = pElem->prop.dotted;
      if( sw<2.1/p->rScale ) sw = 2.1/p->rScale;
      pic_append_dis(p,"stroke-dasharray:",sw,"");
      pic_append_dis(p,",",v,";");
    }else if( pElem->prop.dashed>0.0 ){
      PNum v = pElem->prop.dashed;
      pic_append_dis(p,"stroke-dasharray:",v,"");
      pic_append_dis(p,",",v,";");
    }
  }
}

/* Append multiple <text> SGV element for the text fields of the PElem
*/
static void pic_append_txt(Pic *p, PElem *pElem){
  PNum dy = 0.08;
  int n, i, nz;
  PNum x, y;
  const char *z;
  if( p->nErr ) return;
  if( pElem->nTxt==0 ) return;
  n = pElem->nTxt;
  if( n>1 ){
    if( (pElem->aTxt[0].eCode & TP_VMASK)==0 ){
      pElem->aTxt[0].eCode |= TP_ABOVE;
    }
    if( (pElem->aTxt[n-1].eCode & TP_VMASK)==0 ){
      pElem->aTxt[n-1].eCode |= TP_BELOW;
    }
    for(i=0; i<n; i++){
      if( (pElem->aTxt[i].eCode & TP_VMASK)==0 ){
        dy = 0.12;
      }
    }
  }
  x = pElem->ptAt.x;
  for(i=0; i<n; i++){
    PToken *t = &pElem->aTxt[i];
    y = pElem->ptAt.y;
    if( t->eCode & TP_ABOVE ) y += dy;
    if( t->eCode & TP_BELOW ) y -= dy;
    pic_append_x(p, "<text x=\"", x, "\"");
    pic_append_y(p, " y=\"", y, "\"");
    if( t->eCode & TP_RJUST ){
      pic_append(p, " text-anchor=\"end\"", -1);
    }else if( t->eCode & TP_LJUST ){
      pic_append(p, " text-anchor=\"start\"", -1);
    }else{
      pic_append(p, " text-anchor=\"middle\"", -1);
    }
    if( pElem->prop.color>0 ){
      pic_append_clr(p, " fill=\"", pElem->prop.color, "\"");
    }
    pic_append(p, " dominant-baseline=\"central\">", -1);
    z = t->z+1;
    nz = t->n-2;
    while( nz>0 ){
      int j;
      for(j=0; j<nz && z[j]!='\\'; j++){}
      if( j ) pic_append_text(p, z, j, 0);
      nz -= j+1;
      z += j+1;
    }
    pic_append(p, "</text>\n", -1);
  }
}


/*
** Generate an error message for the output.  pErr is the token at which
** the error should point.  zMsg is the text of the error message. If
** either pErr or zMsg is NULL, generate an out-of-memory error message.
**
** This routine is a no-op if there has already been an error reported.
*/
static void pic_error(Pic *p, PToken *pErr, const char *zMsg){
  int i, j;
  int iCol;
  int nExtra;
  char c;
  if( p->nErr ) return;
  p->nErr++;
  if( p->inDebug ){
    pic_append(p," -->\n", 5);
    p->inDebug = 0;
  }
  i = (int)(pErr->z - p->zIn);
  if( pErr==0 || zMsg==0 ){
    pic_append_text(p, "\n<div><p>Out of memory</p></div>\n", -1, 0);
    return;
  }
  for(j=i; j>0 && p->zIn[j-1]!='\n'; j--){}
  iCol = i - j;
  for(nExtra=0; (c = p->zIn[i+nExtra])!=0 && c!='\n'; nExtra++){}
  pic_append(p, "<div><pre>\n", -1);
  pic_append_text(p, p->zIn, i+nExtra, 0);
  pic_append(p, "\n", 1);
  for(i=0; i<iCol; i++){ pic_append(p, " ", 1); }
  for(i=0; i<pErr->n; i++) pic_append(p, "^", 1);
  pic_append(p, "\nERROR: ", -1);
  pic_append_text(p, zMsg, -1, 0);
  pic_append(p, "\n", 1);
  pic_append(p, "\n</pre></div>\n", -1);
}

/* Free a complete list of elements */
static void pic_elist_free(Pic *p, PEList *pEList){
  int i;
  if( pEList==0 ) return;
  for(i=0; i<pEList->n; i++){
    pic_elem_free(p, pEList->a[i]);
  }
  free(pEList->a);
  free(pEList);
  return;
}

/* Free a single element, and its substructure */
static void pic_elem_free(Pic *p, PElem *pElem){
  if( pElem==0 ) return;
  free(pElem->zName);
  pic_elist_free(p, pElem->pSublist);
  free(pElem->aPath);
  free(pElem);
}

/* Return true if a bounding box is empty.
*/
static int pic_bbox_isempty(PBox *p){
  return p->sw.x>p->ne.x;
}

/* Initialize a bounding box to an empty container
*/
static void pic_bbox_init(PBox *p){
  p->sw.x = 1.0;
  p->sw.y = 1.0;
  p->ne.x = 0.0;
  p->ne.y = 0.0;
}

/* Enlarge the PBox of the first argument so that it fully
** covers the second PBox
*/
static void pic_bbox_addbox(PBox *pA, PBox *pB){
  if( pic_bbox_isempty(pA) ){
    *pA = *pB;
  }
  if( pic_bbox_isempty(pB) ) return;
  if( pA->sw.x>pB->sw.x ) pA->sw.x = pB->sw.x;
  if( pA->sw.y>pB->sw.y ) pA->sw.y = pB->sw.y;
  if( pA->ne.x<pB->ne.x ) pA->ne.x = pB->ne.x;
  if( pA->ne.y<pB->ne.y ) pA->ne.y = pB->ne.y;
}

/* Enlarge the PBox of the first argument, if necessary, so that
** it contains the PPoint in the second argument
*/
static void pic_bbox_addpt(PBox *pA, PPoint *pPt){
  if( pic_bbox_isempty(pA) ){
    pA->ne = *pPt;
    pA->sw = *pPt;
    return;
  }
  if( pA->sw.x>pPt->x ) pA->sw.x = pPt->x;
  if( pA->sw.y>pPt->y ) pA->sw.y = pPt->y;
  if( pA->ne.x<pPt->x ) pA->ne.x = pPt->x;
  if( pA->ne.y<pPt->y ) pA->ne.y = pPt->y;
}



/* Append a new element onto the end of an element_list.  The
** element_list is created if it does not already exist.  Return
** the new element list.
*/
static PEList *pic_elist_append(Pic *p, PEList *pEList, PElem *pElem){
  if( pElem==0 ) return pEList;
  if( pEList==0 ){
    pEList = malloc(sizeof(*pEList));
    if( pEList==0 ){
      pic_error(p, 0, 0);
      pic_elem_free(p, pElem);
      return 0;
    }
    memset(pEList, 0, sizeof(*pEList));
  }
  if( pEList->n>=pEList->nAlloc ){
    int nNew = (pEList->n+5)*2;
    PElem **pNew = realloc(pEList->a, sizeof(PElem*)*nNew);
    if( pNew==0 ){
      pic_error(p, 0, 0);
      pic_elem_free(p, pElem);
      return pEList;
    }
    pEList->a = pNew;
  }
  pEList->a[pEList->n++] = pElem;   
  p->list = pEList;
  return pEList;
}

/* Convert an element class name into a PClass pointer
*/
static const PClass *pic_find_class(PToken *pId){
  int i;
  for(i=0; i<count(aClass); i++){
    if( strncmp(aClass[i].zName, pId->z, pId->n)==0 
     && aClass[i].zName[pId->n]==0
    ){
      return &aClass[i];
    }
  }
  if( pic_token_eq(pId,"text")==0 ){
    return &textClass;
  }
  return 0;
}

/* Allocate and return a new PElem object.
*/
static PElem *pic_elem_new(Pic *p, PToken *pId, PToken *pStr,PEList *pSublist){
  PElem *pNew;

  pNew = malloc( sizeof(*pNew) );
  if( pNew==0 ){
    pic_error(p,0,0);
    pic_elist_free(p, pSublist);
    return 0;
  }
  memset(pNew, 0, sizeof(*pNew));
  p->cur = pNew;
  p->nRPath = 1;
  p->thenFlag = 0;
  p->aRPath[0].isRel = 1;
  p->aRPath[0].pt.x = 0.0;
  p->aRPath[0].pt.y = 0.0;
  pNew->outDir = pNew->inDir = p->eDir;
  pNew->prop.chop1 = pNew->prop.chop2 = -1.0;
  if( pSublist ){
    pNew->type = &sublistClass;
    pNew->pSublist = pSublist;
    sublistClass.xInit(p,pNew);
    return pNew;
  }
  if( pStr ){
    pNew->type = &textClass;
    textClass.xInit(p, pNew);
    pic_add_txt(p, pStr, pStr->eCode);
    return pNew;
  }
  if( pId ){
    const PClass *pClass = pic_find_class(pId);
    if( pClass ){
      pNew->type = pClass;
      pNew->prop.sw = pic_value(p, "thickness",9,0);
      pNew->prop.fill = pic_value(p, "fill",4,0);
      pNew->prop.color = pic_value(p, "color",5,0);
      pClass->xInit(p, pNew);
      return pNew;
    }
    pic_error(p, pId, "unknown element type");
  }
  pic_elem_free(p, pNew);
  p->cur = 0;
  return 0;
}

/*
** Set the output direction and exit point for an element.
*/
static void pic_elem_set_exit(Pic *p, PElem *pElem, int eDir){
  pElem->outDir = eDir;
  if( !pElem->type->isLine ){
    pElem->ptExit = pElem->ptAt;
    switch( pElem->outDir ){
      default:       pElem->ptExit.x += pElem->prop.w*0.5;  break;
      case T_LEFT:   pElem->ptExit.x -= pElem->prop.w*0.5;  break;
      case T_UP:     pElem->ptExit.y += pElem->prop.h*0.5;  break;
      case T_DOWN:   pElem->ptExit.y -= pElem->prop.h*0.5;  break;
    }
  }
}

/* Change the direction of travel
*/
static void pic_set_direction(Pic *p, int eDir){
  p->eDir = eDir;
  if( p->list && p->list->n ){
    pic_elem_set_exit(p, p->list->a[p->list->n-1], eDir);
  }
}

/* Move all coordinates contained within an element (and within its
** substructure) by dx, dy
*/
static void pic_elem_move(PElem *pElem, PNum dx, PNum dy){
  int i;
  pElem->ptAt.x += dx;
  pElem->ptAt.y += dy;
  pElem->ptEnter.x += dx;
  pElem->ptEnter.y += dy;
  pElem->ptExit.x += dx;
  pElem->ptExit.y += dy;
  pElem->bbox.ne.x += dx;
  pElem->bbox.ne.y += dy;
  pElem->bbox.sw.x += dx;
  pElem->bbox.sw.y += dy;
  for(i=0; i<pElem->nPath; i++){
    pElem->aPath[i].x += dx;
    pElem->aPath[i].y += dy;
  }
  if( pElem->pSublist ){
    pic_elist_move(pElem->pSublist, dx, dy);
  }
}
static void pic_elist_move(PEList *pList, PNum dx, PNum dy){
  int i;
  for(i=0; i<pList->n; i++){
    pic_elem_move(pList->a[i], dx, dy);
  }
}

/*
** Set a numeric property like "width 7" or "radius 200%".
**
** The rAbs term is an absolute value to add in.  rRel is
** a relative value by which to change the current value.
*/
void pic_set_numprop(Pic *p, PToken *pId, PNum rAbs, PNum rRel){
  struct PProp *pProp = &p->cur->prop;
  switch( pId->eType ){
    case T_HEIGHT:     pProp->h = pProp->h*rRel + rAbs;    break;
    case T_WIDTH:      pProp->w = pProp->w*rRel + rAbs;    break;
    case T_RADIUS:     rAbs *= 2.0;                        /* fall through */
    case T_DIAMETER:   pProp->w = pProp->w*rRel + rAbs;
                       pProp->h = pProp->h*rRel + rAbs;    break;
    case T_RX:         pProp->rx = pProp->rx*rRel + rAbs;  break;
    case T_RY:         pProp->ry = pProp->ry*rRel + rAbs;  break;
    case T_THICKNESS:  pProp->sw = pProp->sw*rRel + rAbs;  break;
    case T_FILL:       pProp->fill = rAbs;                 break;
    case T_COLOR:      pProp->color = rAbs;                break;
  }
}

/*
** Set a "dashed" property like "dash 0.05" or "chop"
**
** Use the value supplied by pVal if available.  If pVal==0, use
** a default.
*/
void pic_set_dashed(Pic *p, PToken *pId, PNum *pVal){
  struct PProp *pProp = &p->cur->prop;
  PNum v;
  switch( pId->eType ){
    case T_DOTTED:  {
      v = pVal==0 ? pic_value(p,"dashwid",7,0) : *pVal;
      pProp->dotted = v;
      pProp->dashed = 0.0;
      break;
    }
    case T_DASHED:  {
      v = pVal==0 ? pic_value(p,"dashwid",7,0) : *pVal;
      pProp->dashed = v;
      pProp->dotted = 0.0;
      break;
    }
    case T_CHOP: {
      v = pVal==0 ? pic_value(p,"circlerad",9,0) : *pVal;
      if( pProp->chop1<0.0 ){
        pProp->chop1 = v;
      }else if( pProp->chop2<0.0 ){
        pProp->chop2 = v;
      }else{
        pic_error(p, pId, "too many \"chop\" terms");
      }
      break;
    }
  }
}


/* Add a new term to the path for a line-oriented object by transferring
** the information in the ptTo field over onto the path and into ptFrom
** resetting the ptTo.
*/
static void pic_then(Pic *p, PToken *pToken, PElem *pElem){
  int n;
  if( !pElem->type->isLine ){
    pic_error(p, pToken, "use with line-oriented elements only");
    return;
  }
  n = p->nRPath - 1;
  if( n<1 ){
    pic_error(p, pToken, "no prior path points");
    return;
  }
  p->thenFlag = 1;
}

/* Advance to the next entry in p->aRPath.  Return its index.
*/
static int pic_next_rpath(Pic *p, PToken *pErr){
  int n = p->nRPath - 1;
  if( n+1>=count(p->aRPath) ){
    pic_error(0, pErr, "too many path elements");
    return n;
  }
  n++;
  p->nRPath++;
  p->aRPath[n].pt.x = 0.0;
  p->aRPath[n].pt.y = 0.0;
  return n;
}

/* Add a direction term to an element.  "up 0.5", or "left 3", or "down".
*/
static void pic_add_direction(Pic *p, PToken *pDir, PNum *pVal){
  PElem *pElem = p->cur;
  int n;
  if( !pElem->type->isLine ){
    pic_error(p, pDir, "use with line-oriented elements only");
    return;
  }
  n = p->nRPath - 1;
  if( p->thenFlag || p->aRPath[n].isRel==0 ){
    n = pic_next_rpath(p, pDir);
    p->aRPath[n].isRel = 1;
    p->thenFlag = 0;
  }
  switch( pDir->eType ){
    case T_UP:
       if( p->aRPath[n].pt.y!=0.0 ) n = pic_next_rpath(p, pDir);
       p->aRPath[n].pt.y = pVal ? *pVal : pElem->prop.h;
       break;
    case T_DOWN:
       if( p->aRPath[n].pt.y!=0.0 ) n = pic_next_rpath(p, pDir);
       p->aRPath[n].pt.y = -(pVal ? *pVal : pElem->prop.h);
       break;
    case T_RIGHT:
       if( p->aRPath[n].pt.x!=0.0 ) n = pic_next_rpath(p, pDir);
       p->aRPath[n].pt.x = pVal ? *pVal : pElem->prop.w;
       break;
    case T_LEFT:
       if( p->aRPath[n].pt.x!=0.0 ) n = pic_next_rpath(p, pDir);
       p->aRPath[n].pt.x = -(pVal ? *pVal : pElem->prop.w);
       break;
  }
  pElem->outDir = pDir->eType;
  p->aRPath[n].isRel = 1;
}

/* Set the "from" of an element
*/
static void pic_set_from(Pic *p, PElem *pElem, PToken *pTk, PPoint *pPt){
  if( !pElem->type->isLine ){
    pic_error(p, pTk, "use \"at\" to position this object");
    return;
  }
  if( p->aRPath[0].isRel==0 ){
    pic_error(p, pTk, "location already fixed");
    return;
  }
  p->aRPath[0].pt = *pPt;
  p->aRPath[0].isRel = 0;
}

/* Set the "to" of an element
*/
static void pic_add_to(Pic *p, PElem *pElem, PToken *pTk, PPoint *pPt){
  int n = p->nRPath-1;
  if( !pElem->type->isLine ){
    pic_error(p, pTk, "use \"at\" to position this object");
    return;
  }
  if( p->aRPath[n].isRel==0 
   || p->aRPath[n].pt.x!=0
   || p->aRPath[n].pt.y!=0
  ){
    n = pic_next_rpath(p, pTk);
  }
  p->aRPath[n].isRel = 0;
  p->aRPath[n].pt = *pPt;
}

/* Set the "at" of an element
*/
static void pic_set_at(Pic *p, PToken *pEdge, PPoint *pAt, PToken *pErrTok){
  PElem *pElem;
  if( p->nErr ) return;
  pElem = p->cur;
  if( pElem->type->isLine ){
    pic_error(p, pErrTok, "use \"from\" and \"to\" to position this object");
    return;
  }
  if( p->aRPath[0].isRel==0 ){
    pic_error(p, pErrTok, "location already fixed");
    return;
  }
  if( pEdge ){
    PPoint ofst = pic_elem_offset(p,pElem,pEdge->eCode);
    p->aRPath[0].pt.x = pAt->x - ofst.x;
    p->aRPath[0].pt.y = pAt->y - ofst.y;
  }else{   
    p->aRPath[0].pt = *pAt;
  }
  p->aRPath[0].isRel = 0;
  if( pElem->pSublist ){
    pic_elist_move(pElem->pSublist, p->aRPath[0].pt.x, p->aRPath[0].pt.y);
  }
}

/*
** Try to add a text attribute to an element
*/
static void pic_add_txt(Pic *p, PToken *pTxt, int iPos){
  PElem *pElem = p->cur;
  PToken *pT;
  if( pElem->nTxt >= count(pElem->aTxt) ){
    pic_error(p, pTxt, "too many text terms");
    return;
  }
  pT = &pElem->aTxt[pElem->nTxt++];
  *pT = *pTxt;
  pT->eCode = iPos;
}

/* Merge "text-position" flags
*/
static int pic_text_position(Pic *p, int iPrev, PToken *pFlag){
  int iRes = iPrev;
  switch( pFlag->eType ){
    case T_CENTER:   /* no-op */                          break;
    case T_LJUST:    iRes = (iRes&~TP_JMASK) | TP_LJUST;  break;
    case T_RJUST:    iRes = (iRes&~TP_JMASK) | TP_RJUST;  break;
    case T_ABOVE:    iRes = (iRes&~TP_VMASK) | TP_ABOVE;  break;
    case T_BELOW:    iRes = (iRes&~TP_VMASK) | TP_BELOW;  break;
  }
  return iRes;
}




/* Set a local variable name to "val".
**
** The name might be a built-in variable or a color name.  In either case,
** a new application-defined variable is set.  Since app-defined variables
** are searched first, this will override any built-in variables.
*/
static void pic_set_var(Pic *p, PToken *pId, PNum val){
  PVar *pVar = p->pVar;
  while( pVar ){
    if( pic_token_eq(pId,pVar->zName)==0 ) break;
    pVar = pVar->pNext;
  }
  if( pVar==0 ){
    char *z;
    pVar = malloc( pId->n+1 + sizeof(*pVar) );
    if( pVar==0 ){
      pic_error(p, 0, 0);
      return;
    }
    pVar->zName = z = (char*)&pVar[1];
    memcpy(z, pId->z, pId->n);
    z[pId->n] = 0;
    pVar->pNext = p->pVar;
    p->pVar = pVar;
  }
  pVar->val = val;
}

/*
** Search for the variable named z[0..n-1] in:
**
**   * Application defined variables
**   * Built-in variables
**
** Return the value of the variable if found.  If not found
** return 0.0.  Also if pMiss is not NULL, then set it to 1
** if not found.
**
** This routine is a subroutine to pic_get_var().  But it is also
** used by object implementations to look up (possibly overwritten)
** values for built-in variables like "boxwid".
*/
static PNum pic_value(Pic *p, const char *z, int n, int *pMiss){
  PVar *pVar;
  int first, last, mid, c;
  for(pVar=p->pVar; pVar; pVar=pVar->pNext){
    if( strncmp(pVar->zName,z,n)==0 && pVar->zName[n]==0 ){
      return pVar->val;
    }
  }
  first = 0;
  last = count(aBuiltin)-1;
  while( first<=last ){
    mid = (first+last)/2;
    c = strncmp(z,aBuiltin[mid].zName,n);
    if( c==0 && aBuiltin[mid].zName[n] ) c = 1;
    if( c==0 ) return aBuiltin[mid].val;
    if( c>0 ){
      first = mid+1;
    }else{
      last = mid-1;
    }
  }
  if( pMiss ) *pMiss = 1;
  return 0.0;
}

/*
** Look up a color-name.  Return negative if not found.
** Unlike most other things, the color-names are not case
** sensitive.  So "DarkBlue" and "darkblue" and "DARKBLUE"
** all find the same value (139).
*/
static PNum pic_lookup_color(Pic *p, PToken *pId){
  int first, last, mid, c;
  first = 0;
  last = count(aColor)-1;
  while( first<=last ){
    const char *zClr;
    int c1, c2, i;
    mid = (first+last)/2;
    zClr = aColor[mid].zName;
    for(i=0; i<pId->n; i++){
      c1 = zClr[i]&0x7f;
      if( isupper(c1) ) c1 = tolower(c1);
      c2 = pId->z[i]&0x7f;
      if( isupper(c2) ) c2 = tolower(c2);
      c = c2 - c1;
      if( c ) break;
    }
    if( c==0 && aColor[mid].zName[pId->n] ) c = -1;
    if( c==0 ) return (double)aColor[mid].val;
    if( c>0 ){
      first = mid+1;
    }else{
      last = mid-1;
    }
  }
  if( p ) pic_error(p, pId, "not a known color name");
  return -1.0;
}

/* Get the value of a variable.
**
** Search in order:
**
**    *  Application defined variables
**    *  Built-in variables
**    *  Color names
**
** If no such variable is found, throw an error.
*/
static PNum pic_get_var(Pic *p, PToken *pId){
  int miss = 0;
  PNum v = pic_value(p, pId->z, pId->n, &miss);
  if( miss==0 ) return v;
  v = pic_lookup_color(0, pId);
  if( v>=0.0 ) return v;
  pic_error(p,pId,"no such variable");
  return 0.0;
}

/*
** Convert a hex digit into an integer
*/
static int pic_hexval(char c){
  if( c>='0' && c<='9' ) return c - '0';
  if( c>='a' && c<='f' ) return (c - 'a')+10;
  if( c>='A' && c<='F' ) return (c - 'A')+10;
  return 0;
}

/*
** Convert an RGV color value of the form #HHH or #HHHHHH into
** a PNum.
*/
static PNum pic_color_to_num(Pic *p, const char *z, int n){
  int x;
  if( n==4 ){
    x = pic_hexval(z[1])*0x110000 
         + pic_hexval(z[2])*0x1100
         + pic_hexval(z[3])*0x11;
  }else if( n==7 ){
    int i;
    for(i=1, x=0; i<=6; i++){
      x = x*16 + pic_hexval(z[i]);
    }
  }
  return (PNum)x;
}

/* Convert a T_NTH token (ex: "2nd", "5th"} into a numeric value and
** return that value.  Throw an error if the value is too big.
*/
static short int pic_nth_value(Pic *p, PToken *pNth){
  int i = atoi(pNth->z);
  if( i>1000 ){
    pic_error(p, pNth, "value too big - max '1000th'");
    i = 1;
  }
  return i;
}

/* Search for the NTH element.
**
** If pBasis is not NULL then it should be a [] element.  Use the
** sublist of that [] element for the search.  If pBasis is not a []
** element, then throw an error.
**
** The pNth token describes the N-th search.  The pNth->eCode value
** is one more than the number of items to skip.  It is negative
** to search backwards.  If pNth->eType==T_ID, then it is the name
** of a primative time to search for.  If pNth->eType==T_LB, then
** search for a [] object.  If pNth->eType==T_LAST, then search for
** any type.
**
** Raise an error if the item is not found.
*/
static PElem *pic_find_nth(Pic *p, PElem *pBasis, PToken *pNth){
  PEList *pList;
  int i, n;
  const PClass *pClass;
  if( pBasis==0 ){
    pList = p->list;
  }else{
    pList = pBasis->pSublist;
  }
  if( pList==0 ){
    pic_error(p, pNth, "no such object");
    return 0;
  }
  if( pNth->eType==T_LAST ){
    pClass = 0;
  }else if( pNth->eType==T_LB ){
    pClass = &sublistClass;
  }else{
    pClass = pic_find_class(pNth);
    if( pClass==0 ){
      pic_error(0, pNth, "no such object type");
      return 0;
    }
  }
  n = pNth->eCode;
  if( n<0 ){
    for(i=pList->n-1; i>=0; i--){
      PElem *pElem = pList->a[i];
      if( pClass && pElem->type!=pClass ) continue;
      n++;
      if( n==0 ){ return pElem; }
    }
  }else{
    for(i=0; i<pList->n; i++){
      PElem *pElem = pList->a[i];
      if( pClass && pElem->type!=pClass ) continue;
      n--;
      if( n==0 ){ return pElem; }
    }
  }
  pic_error(p, pNth, "no such object");
  return 0;
}

/* Search for an element by name.
**
** Search in pBasis->pSublist if pBasis is not NULL.  If pBasis is NULL
** then search in p->list.
*/
static PElem *pic_find_byname(Pic *p, PElem *pBasis, PToken *pName){
  PEList *pList;
  int i;
  if( pBasis==0 ){
    pList = p->list;
  }else{
    pList = pBasis->pSublist;
  }
  if( pList==0 ){
    pic_error(p, pName, "no such object");
    return 0;
  }
  for(i=pList->n-1; i>=0; i--){
    PElem *pElem = pList->a[i];
    if( pElem->zName && pic_token_eq(pName,pElem->zName)==0 ){
      return pElem;
    }
  }
  pic_error(p, pName, "no such object");
  return 0;
}

/* Return a "Place" associated with element pElem.  If pEdge is NULL
** return the center of the object.  Otherwise, return the corner
** described by pEdge.
*/
static PPoint pic_place_of_elem(Pic *p, PElem *pElem, PToken *pEdge){
  PPoint pt;
  const PClass *pClass;
  pt.x = 0.0;
  pt.y = 0.0;
  if( pElem==0 ) return pt;
  if( pEdge==0 ){
    return pElem->ptAt;
  }
  pClass = pElem->type;
  if( pEdge->eType==T_EDGE ){
    if( pClass->isLine ){
      pic_error(0, pEdge,
          "line objects have only \"start\" and \"end\" points");
      return pt;
    }
    if( pClass->xOffset==0 ){
      pt = boxOffset(p, pElem, pEdge->eCode);
    }else{
      pt = pClass->xOffset(p, pElem, pEdge->eCode);
    }
    pt.x += pElem->ptAt.x;
    pt.y += pElem->ptAt.y;
    return pt;
  }
  if( !pClass->isLine ){
    pic_error(0, pEdge,
          "only line objects have \"start\" and \"end\" points");
    return pt;
  }
  if( pEdge->eType==T_START ){
    return pElem->ptAt;
  }else{
    return pElem->aPath[pElem->nPath-1];
  }
}

/* Do a linear interpolation of two positions.
*/
static PPoint pic_position_between(Pic *p, PNum x, PPoint p1, PPoint p2){
  PPoint out;
  if( x<0.0 ) x = 0.0;
  if( x>1.0 ) x = 1.0;
  out.x = p1.x*x + p2.x*(1.0 - x);
  out.y = p1.y*x + p2.y*(1.0 - x);
  return out;
}

/* Compute the position that is dist away from pt at an heading angle of r
**
** The angle is compass heading in degrees.  North is 0 (or 360).
** East is 90.  South is 180.  West is 270.  And so forth.
*/
static PPoint pic_position_at_angle(Pic *p, PNum dist, PNum r, PPoint pt){
  r *= 0.017453292519943295769;  /* degrees to radians */
  pt.x += dist*sin(r);
  pt.y += dist*cos(r);
  return pt;
}

/* Compute the position that is dist away at a compass point
*/
static PPoint pic_position_at_hdg(Pic *p, PNum dist, PToken *pD, PPoint pt){
  return pic_position_at_angle(p, dist, pic_hdg_angle[pD->eCode], pt);
}

/* Return the value of a property of an object.
*/
static PNum pic_property_of(Pic *p, PElem *pElem, PToken *pProp){
  PNum v = 0.0;
  switch( pProp->eType ){
    case T_HEIGHT:    v = pElem->prop.h;       break;
    case T_WIDTH:     v = pElem->prop.w;       break;
    case T_RX:        v = pElem->prop.rx;      break;
    case T_RADIUS:    /* fall through */
    case T_RY:        v = pElem->prop.ry;      break;
    case T_DIAMETER:  v = pElem->prop.ry*2.0;  break;
    case T_THICKNESS: v = pElem->prop.sw;      break;
    case T_DASHED:    v = pElem->prop.dashed;  break;
    case T_DOTTED:    v = pElem->prop.dotted;  break;
    case T_CHOP:      v = pElem->prop.chop2;
         if( v<0.0 )  v = 0.0;                 break;
    case T_FILL:      v = pElem->prop.fill;    break;
    case T_COLOR:     v = pElem->prop.color;   break;
    case T_X:         v = pElem->ptAt.x;       break;
    case T_Y:         v = pElem->ptAt.y;       break;
    case T_TOP:       v = pElem->bbox.ne.y;    break;
    case T_BOTTOM:    v = pElem->bbox.sw.y;    break;
    case T_LEFT:      v = pElem->bbox.sw.x;    break;
    case T_RIGHT:     v = pElem->bbox.ne.x;    break;
  }
  return v;
}

/* Compute one of the built-in functions
*/
static PNum pic_func(Pic *p, PToken *pFunc, PNum x, PNum y){
  PNum v = 0.0;
  switch( pFunc->eCode ){
    case FN_COS:  v = cos(x);   break;
    case FN_INT:  v = floor(x); break;
    case FN_SIN:  v = sin(x);   break;
    case FN_SQRT:
      if( x<0.0 ){
        pic_error(p, pFunc, "sqrt of negative value");
        v = 0.0;
      }else{
        v = sqrt(x);
      }
      break;
    case FN_MAX:  v = x>y ? x : y;   break;
    case FN_MIN:  v = x<y ? x : y;   break;
    default:      v = 0.0;
  }
  return v;
}

/* Attach a name to an element
*/
static void pic_elem_setname(Pic *p, PElem *pElem, PToken *pName){
  if( pElem==0 ) return;
  if( pName==0 ) return;
  free(pElem->zName);
  pElem->zName = malloc(pName->n+1);
  if( pElem->zName==0 ){
    pic_error(p,0,0);
  }else{
    memcpy(pElem->zName,pName->z,pName->n);
    pElem->zName[pName->n] = 0;
  }
  return;
}

/* This routine runs after all attributes have been received
** on an element.
*/
static void pic_after_adding_attributes(Pic *p, PElem *pElem){
  int i;
  int isConnected;

  /* Convert the starting point to absolute coordinates.  If
  ** the starting point is currently relative (meaning that it
  ** is unspecified by attributes) then make the starting point
  ** equal to the exit point of the previous object.
  */
  if( p->aRPath[0].isRel ){
    PPoint ptStart;
    if( p->list==0 || p->list->n==0 ){
      ptStart = p->ptStart;
    }else{
      PElem *pPrior = p->list->a[p->list->n-1];
      ptStart = pPrior->ptExit;
    }
    p->aRPath[0].pt.x = ptStart.x;
    p->aRPath[0].pt.y = ptStart.y;
    p->aRPath[0].isRel = 0;
    if( pElem->pSublist ){
      pic_elist_move(pElem->pSublist, ptStart.x, ptStart.y);
    }
    isConnected = 1;
  }else{
    /* Absolute location was specified */
    isConnected = 0;
  }

  /* For a line object with no movement specified, a single movement
  ** of the default length in the current direction
  */
  if( pElem->type->isLine && p->nRPath<2 ){
    PPoint *pPt = &p->aRPath[1].pt;
    p->nRPath = 2;
    p->aRPath[1].isRel = 1;
    switch( pElem->inDir ){
      default:      pPt->x = +pElem->prop.w; pPt->y = 0.0; break;
      case T_LEFT:  pPt->x = -pElem->prop.w; pPt->y = 0.0; break;
      case T_UP:    pPt->y = +pElem->prop.h; pPt->x = 0.0; break;
      case T_DOWN:  pPt->y = -pElem->prop.h; pPt->x = 0.0; break;
    }
  }

  /* Convert the path to absolute coordinates */
  for(i=1; i<p->nRPath; i++){
    if( p->aRPath[i].isRel ){
      p->aRPath[i].pt.x += p->aRPath[i-1].pt.x;
      p->aRPath[i].pt.y += p->aRPath[i-1].pt.y;
      p->aRPath[i].isRel = 0;
    }
  }

  /* Fix up the chop parameters */
  if( pElem->prop.chop1>=0.0 && pElem->prop.chop2<0.0 ){
    pElem->prop.chop2 = pElem->prop.chop1;
  }

  /* Compute final bounding box, entry and exit points, center
  ** point (ptAt) and path for the element
  */
  pic_bbox_init(&pElem->bbox);
  pElem->ptEnter = p->aRPath[0].pt;
  if( pElem->type->isLine ){
    pElem->aPath = malloc( sizeof(PPoint)*p->nRPath );
    if( pElem->aPath==0 ){
      pic_error(p, 0, 0);
      pElem->nPath = 0;
    }else{
      pElem->nPath = p->nRPath;
      for(i=0; i<p->nRPath; i++){
        pElem->aPath[i] = p->aRPath[i].pt;
        pic_bbox_addpt(&pElem->bbox, &pElem->aPath[i]);
      }
    }
    pElem->ptExit = p->aRPath[p->nRPath-1].pt;
    pElem->prop.w = pElem->bbox.ne.x - pElem->bbox.sw.x;
    pElem->prop.h = pElem->bbox.ne.y - pElem->bbox.sw.y;
    pElem->ptAt.x = (pElem->bbox.ne.x + pElem->bbox.sw.x)/2.0;
    pElem->ptAt.y = (pElem->bbox.ne.y + pElem->bbox.sw.y)/2.0;
  }else{
    PNum w2 = pElem->prop.w/2.0;
    PNum h2 = pElem->prop.h/2.0;
    pElem->ptAt = p->aRPath[0].pt;
    if( isConnected ){
      switch( pElem->inDir ){
        default:       pElem->ptAt.x += w2;  break;
        case T_LEFT:   pElem->ptAt.x -= w2;  break;
        case T_UP:     pElem->ptAt.y += h2;  break;
        case T_DOWN:   pElem->ptAt.y -= h2;  break;
      }
    }
    pic_elem_set_exit(p, pElem, pElem->outDir);
    pElem->bbox.sw.x = pElem->ptAt.x - w2;
    pElem->bbox.sw.y = pElem->ptAt.y - h2;
    pElem->bbox.ne.x = pElem->ptAt.x + w2;
    pElem->bbox.ne.y = pElem->ptAt.y + h2;
  }
  p->eDir = pElem->outDir;
}

/* Render a single element
*/
static void pic_elem_render(Pic *p, PElem *pElem){
  if( pElem==0 ) return;
  pic_append(p,"<!-- ", -1);
  if( pElem->zName ){
    pic_append_text(p, pElem->zName, -1, 0);
    pic_append(p, ": ", 2);
  }
  pic_append_text(p, pElem->type->zName, -1, 0);
  if( pElem->nTxt ){
    pic_append(p, " \"", 2);
    pic_append_text(p, pElem->aTxt[0].z+1, pElem->aTxt[0].n-2, 1);
    pic_append(p, "\"", 1);
  }
  pic_append(p, " width ", 7);
  pic_append_num(p, pElem->prop.w);
  pic_append(p, " height ", 8);
  pic_append_num(p, pElem->prop.h);
  pic_append(p, " at ", 4);
  pic_append_num(p, pElem->ptAt.x);
  pic_append(p, ",", 1);
  pic_append_num(p, pElem->ptAt.y);
  pic_append(p, " -->\n", -1);
}

/* Render a list of elements
*/
void pic_elist_render(Pic *p, PEList *pEList){
  int i;
  for(i=0; i<pEList->n; i++){
    PElem *pElem = pEList->a[i];
    void (*xRender)(Pic*,PElem*);
    pic_elem_render(p, pElem);
    xRender = pElem->type->xRender;
    if( xRender ){
      xRender(p, pElem);
    }
    if( pElem->pSublist ){
      pic_elist_render(p, pElem->pSublist);
    }
  }
}

/* Render a list of elements.  Write the SVG into p->zOut.
** Delete the input element_list before returnning.
*/
static void pic_render(Pic *p, PEList *pEList){
  int i;
  if( pEList==0 ) return;
  if( p->nErr==0 ){
    PNum thickness = pic_value(p,"thickness",9,0);
    if( thickness<=0.01 ) thickness = 0.01;
    p->wArrow = 0.5*pic_value(p,"arrowwid",8,0)/thickness;
    p->hArrow = pic_value(p,"arrowht",7,0)/thickness;
    pic_bbox_init(&p->bbox);
    for(i=0; i<pEList->n; i++){
      PElem *pElem = pEList->a[i];
      pic_bbox_addbox(&p->bbox, &pElem->bbox);
    }
    p->rScale = 144.0*pic_value(p,"scale",5,0);
    if( p->rScale<5.0 ) p->rScale = 5.0;
    p->bbox.ne.x += thickness;
    p->bbox.ne.y += thickness;
    p->bbox.sw.x -= thickness;
    p->bbox.sw.y -= thickness;
    pic_append_dis(p, "<svg width=\"", p->bbox.ne.x - p->bbox.sw.x, "\"");
    pic_append_dis(p, " height=\"",p->bbox.ne.y - p->bbox.sw.y,"\">\n");
    pic_elist_render(p, pEList);
    pic_append(p,"</svg>\n", -1);
  }
  pic_elist_free(p, pEList);
}



/*
** An array of this structure defines a list of keywords.
*/
typedef struct PicWord {
  char *zWord;                /* Text of the keyword */
  short unsigned int nChar;   /* Length of keyword text in bytes */
  short unsigned int eType;   /* Token code */
  short unsigned int eCode;   /* Extra code for the token */
} PicWord;

/*
** Keywords
*/
static const PicWord pic_keywords[] = {
  { "above",      5,   T_ABOVE,     0         },
  { "and",        3,   T_AND,       0         },
  { "angle",      5,   T_ANGLE,     0         },
  { "as",         2,   T_AS,        0         },
  { "at",         2,   T_AT,        0         },
  { "behind",     6,   T_BEHIND,    0         },
  { "below",      5,   T_BELOW,     0         },
  { "between",    7,   T_BETWEEN,   0         },
  { "bottom",     6,   T_BOTTOM,    0         },
  { "c",          1,   T_EDGE,      CP_C      },
  { "ccw",        3,   T_CCW,       0         },
  { "center",     6,   T_CENTER,    0         },
  { "chop",       4,   T_CHOP,      0         },
  { "color",      5,   T_COLOR,     0         },
  { "cos",        3,   T_FUNC1,     FN_COS    },
  { "cw",         2,   T_CW,        0         },
  { "dashed",     6,   T_DASHED,    0         },
  { "diameter",   8,   T_DIAMETER,  0         },
  { "dotted",     6,   T_DOTTED,    0         },
  { "down",       4,   T_DOWN,      0         },
  { "e",          1,   T_EDGE,      CP_E      },
  { "east",       4,   T_EDGE,      CP_E      },
  { "end",        3,   T_END,       0         },
  { "fill",       4,   T_FILL,      0         },
  { "from",       4,   T_FROM,      0         },
  { "height",     6,   T_HEIGHT,    0         },
  { "in",         2,   T_IN,        0         },
  { "int",        3,   T_FUNC1,     FN_INT    },
  { "invisible",  9,   T_INVIS,     0         },
  { "last",       4,   T_LAST,      0         },
  { "left",       4,   T_LEFT,      0         },
  { "ljust",      5,   T_LJUST,     0         },
  { "max",        3,   T_FUNC2,     FN_MAX    },
  { "min",        3,   T_FUNC2,     FN_MIN    },
  { "n",          1,   T_EDGE,      CP_N      },
  { "ne",         2,   T_EDGE,      CP_NE     },
  { "north",      5,   T_EDGE,      CP_N      },
  { "nw",         2,   T_EDGE,      CP_NW     },
  { "of",         2,   T_OF,        0         },
  { "print",      5,   T_PRINT,     0         },
  { "radius",     6,   T_RADIUS,    0         },
  { "right",      5,   T_RIGHT,     0         },
  { "rjust",      5,   T_RJUST,     0         },
  { "rx",         2,   T_RX,        0         },
  { "ry",         2,   T_RY,        0         },
  { "s",          1,   T_EDGE,      CP_S      },
  { "same",       4,   T_SAME,      0         },
  { "se",         2,   T_EDGE,      CP_SE     },
  { "sin",        3,   T_FUNC1,     FN_SIN    },
  { "south",      5,   T_EDGE,      CP_S      },
  { "sqrt",       4,   T_FUNC1,     FN_SQRT   },
  { "start",      5,   T_START,     0         },
  { "sw",         2,   T_EDGE,      CP_SW     },
  { "the",        3,   T_THE,       0         },
  { "then",       4,   T_THEN,      0         },
  { "thickness",  9,   T_THICKNESS, 0         },
  { "to",         2,   T_TO,        0         },
  { "top",        3,   T_TOP,       0         },
  { "up",         2,   T_UP,        0         },
  { "w",          1,   T_EDGE,      CP_W      },
  { "way",        3,   T_WAY,       0         },
  { "west",       4,   T_EDGE,      CP_W      },
  { "width",      5,   T_WIDTH,     0         },
  { "with",       4,   T_WITH,      0         },
  { "x",          1,   T_X,         0         },
  { "y",          1,   T_Y,         0         },
};

/*
** Search a PicWordlist for the given keyword.  A pointer to the
** element found.  Or return 0 if not found.
*/
static const PicWord *pic_find_word(
  const char *zIn,              /* Word to search for */
  int n,                        /* Length of zIn */
  const PicWord *aList,         /* List to search */
  int nList                     /* Number of entries in aList */
){
  int first = 0;
  int last = nList-1;
  while( first<=last ){
    int mid = (first + last)/2;
    int sz = aList[mid].nChar;
    int c = strncmp(zIn, aList[mid].zWord, sz<n ? sz : n);
    if( c==0 ){
      c = n - sz;
      if( c==0 ) return &aList[mid];
    }
    if( c<0 ){
      last = mid-1;
    }else{
      first = mid+1;
    }
  }
  return 0;
}


/*
** Return the length of next token  Write token type into *peType
*/
static int pic_token_length(const char *zStart, int *peType, int *peCode){
  int i;
  char c;
  switch( zStart[0] ){
    case '\\': {
      *peType = T_WHITESPACE;
      if( zStart[1]=='\n'  ) return 2;
      if( zStart[1]=='\r' && zStart[2]=='\n' ) return 3;
      *peType = T_ERROR;
      return 1;
    }
    case ';':
    case '\n': {
      *peType = T_EOL;
      return 1;
    }
    case '"': {
      for(i=1; (c = zStart[i])!=0; i++){
        if( c=='\\' ){ i++; continue; }
        if( c=='"' ){
          *peType = T_STRING;
          return i+1;
        }
      }
      *peType = T_ERROR;
      return i;
    }
    case ' ':
    case '\t':
    case '\f':
    case '\r': {
      for(i=1; (c = zStart[i])==' ' || c=='\t' || c=='\r' || c=='\t'; i++){}
      *peType = T_WHITESPACE;
      return i;
    }
    case '#': {
      for(i=1; isxdigit(zStart[i]); i++){}
      if( i==4 || i==7 ){
        *peType = T_HEXRGB;
        return i;
      }
      for(i=1; (c = zStart[i])!=0 && c!='\n'; i++){}
      *peType = T_WHITESPACE;
      return i;
    }
    case '/': {
      if( zStart[1]=='*' ){
        for(i=2; zStart[i]!=0 && (zStart[i]!='*' || zStart[i+1]!='/'); i++){}
        if( zStart[i]=='*' ){
          *peType = T_WHITESPACE;
          return i+2;
        }else{
          *peType = T_ERROR;
          return i;
        }
      }else if( zStart[1]=='/' ){
        for(i=2; zStart[i]!=0 && zStart[i]!='\n'; i++){}
        if( zStart[i]!=0 ) i++;
        *peType = T_WHITESPACE;
        return i;
      }else{
        *peType = T_SLASH;
        return 1;
      }
    }
    case '+': {   *peType = T_PLUS;    return 1; }
    case '*': {   *peType = T_STAR;    return 1; }
    case '%': {   *peType = T_PERCENT; return 1; }
    case '(': {   *peType = T_LP;      return 1; }
    case ')': {   *peType = T_RP;      return 1; }
    case '[': {   *peType = T_LB;      return 1; }
    case ']': {   *peType = T_RB;      return 1; }
    case ',': {   *peType = T_COMMA;   return 1; }
    case ':': {   *peType = T_COLON;   return 1; }
    case '=': {   *peType = T_ASSIGN;  return 1; }
    case '-': {
      if( zStart[1]=='>' ){
        *peType = T_RARROW;
        return 2;
      }else{
        *peType = T_MINUS;
        return 1;
      }
    }
    case '<': { 
      if( zStart[1]=='-' ){
         if( zStart[2]=='>' ){
           *peType = T_LRARROW;
           return 3;
         }else{
           *peType = T_LARROW;
           return 2;
         }
      }else{
        *peType = T_ERROR;
         return 1;
      }
    }
    default: {
      c = zStart[0];
      if( c=='.' ){
        char c1 = zStart[1];
        if( c1>='a' && c1<='z' ){
          const PicWord *pFound;
          for(i=2; (c = zStart[i])>='a' && c<='z'; i++){}
          pFound = pic_find_word(zStart+1, i-1,
                                    pic_keywords, count(pic_keywords));
          if( pFound && pFound->eType==T_EDGE ){
            *peType = T_DOT_E;
          }else{
            *peType = T_DOT_L;
          }
          return 1;
        }else if( c1>='0' && c1<='9' ){
          /* no-op.  Fall through to number handling */
        }else if( c1>='A' && c1<='Z' ){
          for(i=2; (c = zStart[i])!=0 && (isalnum(c) || c=='_'); i++){}
          *peType = T_DOT_U;
          return 1;
        }else{
          *peType = T_ERROR;
          return 1;
        }
      }
      if( (c>='0' && c<='9') || c=='.' ){
        int nDigit;
        int notInt = 0;
        if( c!='.' ){
          nDigit = 1;
          for(i=1; (c = zStart[i])>='0' && c<='9'; i++){ nDigit++; }
        }else{
          notInt = 1;
          nDigit = 0;
        }
        if( c=='.' ){
          notInt = 1;
          for(i++; (c = zStart[i])>='0' && c<='9'; i++){ nDigit++; }
        }
        if( nDigit==0 ){
          *peType = T_ERROR;
          return i;
        }
        if( c=='e' || c=='E' ){
          i++;
          c = zStart[i];
          if( c=='+' || c=='-' ){
            i++;
            c = zStart[i];
          }
          if( c<'0' || c>'9' ){
            *peType = T_ERROR;
            return i;
          }
          i++;
          notInt = 1;
          while( (c = zStart[i])>=0 && c<='9' ){ i++; }
        }else if( (c=='t' && zStart[i+1]=='h')
               || (c=='r' && zStart[i+1]=='d')
               || (c=='n' && zStart[i+1]=='d')
               || (c=='s' && zStart[i+1]=='t') ){
          *peType = T_NTH;
          if( notInt ) *peType = T_ERROR;
          return i+2;
        }
        *peType = T_NUMBER;
        return i;
      }else if( (c>='a' && c<='z') || c=='_' || c=='$' || c=='@' ){
        const PicWord *pFound;
        for(i=1; (c =  zStart[i])!=0 && (isalnum(c) || c=='_'); i++){}
        pFound = pic_find_word(zStart, i, pic_keywords, count(pic_keywords));
        if( pFound ){
          *peType = pFound->eType;
          *peCode = pFound->eCode;
        }else{
          *peType = T_ID;
        }
        return i;
      }else if( c>='A' && c<='Z' ){
        for(i=1; (c =  zStart[i])!=0 && (isalnum(c) || c=='_'); i++){}
        *peType = T_PLACENAME;
        return i;
      }else{
        *peType = T_ERROR;
        return 1;
      }
    }
  }
}

/*
** Parse the PIC script contained in zText[]
*/
char *pic(const char *zText, int *pnErr){
  int i;
  int sz;
  int eType, eCode;
  PToken token;
  Pic s;
  yyParser sParse;

  memset(&s, 0, sizeof(s));
  s.zIn = zText;
  s.nIn = (unsigned int)strlen(zText);
  s.eDir = T_RIGHT;
  pic_parserInit(&sParse, &s);
#if 0
  pic_parserTrace(stdout, "parser: ");
#endif
  for(i=0; zText[i] && s.nErr==0; i+=sz){
    eCode = 0;
    sz = pic_token_length(zText+i, &eType, &eCode);
    token.z = zText + i;
    token.n = sz;
    token.eType = (unsigned short int)eType;
    token.eCode = (unsigned short int)eCode;
    if( eType==T_WHITESPACE ){
      /* no-op */
    }else if( sz>1000 ){
      token.n = 1;
      pic_error(&s, &token, "token is too long - max length 1000 bytes");
      break;
    }else if( eType==T_ERROR ){
      pic_error(&s, &token, "unrecognized token");
      break;
    }else{
#if 0
      printf("******** Token %s (%d): \"%.*s\" **************\n",
             yyTokenName[token.eType], eType,
             isspace(token.z[0]) ? 0 : token.n, token.z);
#endif
      pic_parser(&sParse, eType, token);
    }
  }
  if( s.nErr==0 ){
    memset(&token,0,sizeof(token));
    pic_parser(&sParse, 0, token);
  }
  pic_parserFinalize(&sParse);
  while( s.pVar ){
    PVar *pNext = s.pVar->pNext;
    free(s.pVar);
    s.pVar = pNext;
  }
  if( pnErr ) *pnErr = s.nErr;
  if( s.zOut ){
    s.zOut[s.nOut] = 0;
    s.zOut = realloc(s.zOut, s.nOut+1);
  }
  return s.zOut;
}

int main(int argc, char **argv){
  int i;
  for(i=1; i<argc; i++){
    FILE *in;
    size_t sz;
    char *zIn;
    char *zOut;

    in = fopen(argv[i], "rb");
    if( in==0 ){
      fprintf(stderr, "cannot open \"%s\" for reading\n", argv[i]);
      continue;
    }
    fseek(in, 0, SEEK_END);
    sz = ftell(in);
    rewind(in);
    zIn = malloc( sz+1 );
    if( zIn==0 ){
      fprintf(stderr, "cannot allocate space for file \"%s\"\n", argv[i]);
      fclose(in);
      continue;
    }
    sz = fread(zIn, 1, sz, in);
    fclose(in);
    zIn[sz] = 0;
    zOut = pic(zIn, 0);
    free(zIn);
    if( zOut ){
      printf("%s", zOut);
      free(zOut);
    }
  }
  return 0; 
}

} // end %code
